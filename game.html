<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•†ä¸šä¸›æ—æ³•åˆ™ - æ²™ç›˜æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        /* å•†ä¸šä¸›æ—èƒŒæ™¯æ•ˆæœ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 107, 107, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(78, 205, 196, 0.1) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundShift 20s ease-in-out infinite;
        }
        
        @keyframes backgroundShift {
            0%, 100% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(-20px) translateY(-10px); }
            50% { transform: translateX(20px) translateY(10px); }
            75% { transform: translateX(-10px) translateY(20px); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(145deg, rgba(139, 69, 19, 0.8), rgba(160, 82, 45, 0.8));
            border-radius: 20px;
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 215, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            animation: headerShine 4s ease-in-out infinite;
        }
        
        @keyframes headerShine {
            0%, 100% { left: -100%; }
            50% { left: 100%; }
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: goldShimmer 3s ease-in-out infinite;
            font-weight: bold;
            position: relative;
            z-index: 2;
        }
        
        @keyframes goldShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            position: relative;
            z-index: 2;
        }

        .game-section {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .game-section:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .section-title {
            font-size: 1.8em;
            margin-bottom: 25px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 3px solid transparent;
            border-image: linear-gradient(45deg, #FFD700, #FFA500) 1;
            padding-bottom: 15px;
            font-weight: bold;
        }

        .player-setup {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .player-card {
            background: linear-gradient(135deg, #2a2a2a, #3a3a3a);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #555;
            transition: all 0.3s ease;
        }

        .player-card:hover {
            border-color: #FFD700;
            transform: translateY(-2px);
        }

        .player-card.active {
            border-color: #00FF00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .player-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .info-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 5px;
            text-align: center;
        }

        .info-label {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .capital { color: #FFD700; }
        .reputation { color: #87CEEB; }
        .class-ruler { color: #FF6B6B; }
        .class-middle { color: #4ECDC4; }
        .class-worker { color: #95E1D3; }

        .btn {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #1a1a1a;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin: 8px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 8px 25px rgba(255, 215, 0, 0.4),
                0 3px 10px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(-1px) scale(1.02);
        }

        .btn:disabled {
            background: linear-gradient(45deg, #666, #555);
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn:disabled::before {
            display: none;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
        }

        .cooperate-btn {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
        }

        .betray-btn {
            background: linear-gradient(45deg, #FF416C, #FF4B2B);
            color: white;
        }

        .game-controls {
            text-align: center;
            margin: 20px 0;
        }

        .round-info {
            background: linear-gradient(45deg, #2C3E50, #34495E);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }

        .round-info h3 {
            font-size: 1.8em;
            margin-bottom: 10px;
            color: #FFD700;
        }

        .opportunity-card {
            background: linear-gradient(135deg, #8B4513, #A0522D);
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 5px solid #FFD700;
        }

        .trait-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .trait-card {
            background: linear-gradient(135deg, #4a4a4a, #5a5a5a);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #666;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .trait-card:hover {
            border-color: #FFD700;
            transform: scale(1.05);
        }

        .trait-card.selected {
            border-color: #00FF00;
            background: linear-gradient(135deg, #2a5a2a, #3a6a3a);
        }

        .cooperation-panel {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .player-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .player-option {
            background: #3a3a3a;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .player-option:hover {
            border-color: #FFD700;
        }

        .player-option.selected {
            border-color: #00FF00;
            background: #2a5a2a;
        }

        .decision-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .cooperate-btn {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
        }

        .betray-btn {
            background: linear-gradient(45deg, #FF416C, #FF4B2B);
        }

        .results-panel {
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .final-results {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #8B4513, #A0522D);
            border-radius: 15px;
            margin: 20px 0;
        }

        .personality-tag {
            font-size: 2em;
            color: #FFD700;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .hidden {
            display: none;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: linear-gradient(135deg, #2a2a2a, #3a3a3a);
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .log-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin: 15px 0;
            font-family: monospace;
            font-size: 0.9em;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #FFD700;
            padding-left: 10px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .player-setup {
                grid-template-columns: 1fr;
            }
            
            .decision-buttons {
                flex-direction: column;
                align-items: center;
            }
        }

        .tag {
            display: inline-block;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin: 2px;
            font-weight: bold;
        }

        .final-rank-item {
            transition: transform 0.3s ease;
        }

        .final-rank-item:hover {
            transform: translateY(-2px);
        }

        .class-ruler {
            color: #ffd700;
            font-weight: bold;
        }

        .class-middle {
            color: #87ceeb;
            font-weight: bold;
        }

        .class-worker {
            color: #dda0dd;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ›ï¸ å•†ä¸šä¸›æ—æ³•åˆ™</h1>
            <p>åœ¨è¿™ä¸ªæ®‹é…·çš„å•†ä¸šä¸–ç•Œä¸­ï¼Œä½ å°†å¦‚ä½•ç”Ÿå­˜ï¼Ÿ</p>
        </div>

        <!-- æ¸¸æˆè®¾ç½®é˜¶æ®µ -->
        <div id="setup-phase" class="game-section">
            <h2 class="section-title">ğŸ­ è§’è‰²åˆ›å»º</h2>
            <div class="game-controls">
                <label for="player-count">ç©å®¶æ•°é‡ï¼š</label>
                <select id="player-count">
                    <option value="6">6äºº</option>
                    <option value="8">8äºº</option>
                    <option value="10">10äºº</option>
                    <option value="12">12äºº</option>
                    <option value="15">15äºº</option>
                    <option value="20">20äºº</option>
                </select>
                <button class="btn" onclick="initializeGame()">å¼€å§‹æ¸¸æˆ</button>
            </div>
            <div id="players-container" class="player-setup"></div>
        </div>

        <!-- æ¸¸æˆè¿›è¡Œé˜¶æ®µ -->
        <div id="game-phase" class="game-section hidden">
            <div class="round-info">
                <h3 id="round-title">ç¬¬1è½® - å•†æœºå‘å¸ƒ</h3>
                <div id="opportunity-card" class="opportunity-card"></div>
            </div>

            <div id="current-player-info" class="game-section">
                <h3 class="section-title">å½“å‰ç©å®¶ä¿¡æ¯</h3>
                <div id="player-status"></div>
            </div>

            <div id="trait-selection" class="game-section">
                <h3 class="section-title">é€‰æ‹©ç‰¹è´¨å¡</h3>
                <div id="trait-cards-container" class="trait-cards"></div>
            </div>

            <div id="cooperation-phase" class="game-section">
                <h3 class="section-title">åˆä½œå†³ç­–</h3>
                <div class="cooperation-panel">
                    <p>é€‰æ‹©åˆä½œå¯¹è±¡ï¼ˆå¯é€‰æ‹©ç‹¬ç«‹è¡ŒåŠ¨ï¼‰ï¼š</p>
                    <div id="cooperation-options" class="player-list"></div>
                    <div class="decision-buttons">
                        <button class="btn cooperate-btn" onclick="makeDecision('cooperate')">å±¥è¡Œåˆä½œ</button>
                        <button class="btn betray-btn" onclick="makeDecision('betray')">èƒŒå›</button>
                        <button class="btn btn-secondary" onclick="makeDecision('independent')">ç‹¬ç«‹è¡ŒåŠ¨</button>
                    </div>
                </div>
            </div>

            <div class="game-controls">
                <button class="btn btn-success" onclick="nextPlayer()">ä¸‹ä¸€ä½ç©å®¶</button>
                <button class="btn btn-secondary" onclick="processRound()">ç»“ç®—æœ¬è½®</button>
            </div>
        </div>

        <!-- ç»“æœæ˜¾ç¤º -->
        <div id="results-phase" class="phase hidden">
            <h2>ç¬¬<span id="current-round-display">1</span>è½®ç»“æœ</h2>
            <div id="round-results"></div>
            <button class="btn" onclick="nextRound()">ä¸‹ä¸€è½®</button>
        </div>

        <!-- æœ€ç»ˆç»“æœé˜¶æ®µ -->
        <div id="final-results" class="phase hidden">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <div id="final-ranking"></div>
            <button class="btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>

        <!-- æ¸¸æˆæ—¥å¿— -->
        <div class="game-section">
            <h3 class="section-title">ğŸ“ æ¸¸æˆæ—¥å¿—</h3>
            <div id="game-log" class="log-panel"></div>
        </div>
    </div>

    <script>
        // æ¸¸æˆæ•°æ®ç»“æ„
        let gameState = {
            players: [],
            currentRound: 1,
            currentPlayerIndex: 0,
            maxRounds: 5,
            gamePhase: 'setup', // setup, playing, results, final
            roundDecisions: [],
            gameLog: []
        };

        // è§’è‰²å®šä¹‰
        const roles = {
            'æ å¤ºè€…': {
                traits: ['æŒ‡å—é’ˆ', 'å²©çŸ³', 'ç«ç„°'],
                description: 'å¤©ç”Ÿé¢†è¢–ï¼Œç›®æ ‡æ˜ç¡®ï¼Œæ„å¿—å¦‚é“',
                secretMission: 'æ¸¸æˆç»“æŸæ—¶èµ„æœ¬æ’åç¬¬1',
                specialSkill: 'å¼ºæƒå¾æœï¼šåœ¨åˆä½œä¸­å¼ºåˆ¶å¤šåˆ†30%æ”¶ç›Šï¼ˆå£°æœ›-15ï¼‰',
                initialCapital: 300,
                initialReputation: 70
            },
            'æ“ç›˜æ‰‹': {
                traits: ['é•œé¢', 'æ¡¥æ¢', 'æ°´æµ'],
                description: 'å¹•åå¸ƒå±€è€…ï¼Œæ´å¯Ÿäººæ€§å¼±ç‚¹',
                secretMission: 'èµ„æœ¬è¿›å…¥å‰3ï¼Œä¸”è‡³å°‘æˆåŠŸèƒŒå›2æ¬¡',
                specialSkill: 'ä¿¡æ¯æ¬ºè¯ˆï¼šä¼ªé€ 1ä»½åˆä½œå¥‘çº¦å†…å®¹',
                initialCapital: 150,
                initialReputation: 50
            },
            'æ•™çˆ¶': {
                traits: ['å²©çŸ³', 'æ¡¥æ¢', 'ç›¾ç‰Œ'],
                description: 'ç§©åºå»ºç«‹è€…ï¼Œæ©å¨å¹¶æ–½',
                secretMission: 'æ‹¥æœ‰â‰¥2å"ç‹—è…¿å­"ä¸”èµ„æœ¬å‰5',
                specialSkill: 'æ”¶ç¼–ä»¤ï¼šæŒ‡å®š1åæ— äº§è€…æˆä¸ºç‹—è…¿å­',
                initialCapital: 300,
                initialReputation: 70
            },
            'å­¤ç‹¼': {
                traits: ['å²©çŸ³', 'ç­‹éª¨', 'ç›¾ç‰Œ'],
                description: 'æè‡´ä¸“ä¸šè€…ï¼Œä¸å±‘äººæƒ…ä¸–æ•…',
                secretMission: 'ä¸ªäººèµ„æœ¬â‰¥200ï¼ˆç‹¬ç«‹è¡ŒåŠ¨æ”¶ç›ŠÃ—1.2ï¼‰',
                specialSkill: 'ç‹¬è¡Œï¼šæœ¬è½®ç‹¬ç«‹è¡ŒåŠ¨æ”¶ç›Š+50%ï¼Œä¸å¯åˆä½œ',
                initialCapital: 150,
                initialReputation: 50
            },
            'é¬£ç‹—': {
                traits: ['é•œé¢', 'æ°´æµ', 'ç«ç„°'],
                description: 'æœºä¼šä¸»ä¹‰æ¸…é“å¤«ï¼Œå—…è§‰çµæ•',
                secretMission: 'èƒŒå›æ¬¡æ•°â‰¥3æ¬¡ä¸”å­˜æ´»åˆ°æœ€å',
                specialSkill: 'è¶ç«æ‰“åŠ«ï¼šå½“ä»–äººåˆä½œå¤±è´¥æ—¶ï¼Œå¯çªƒå–å…¶æŸå¤±èµ„æœ¬çš„30%',
                initialCapital: 50,
                initialReputation: 30
            },
            'ç‹—è…¿å­': {
                traits: ['ç­‹éª¨', 'æ¡¥æ¢'],
                description: 'æ‰§è¡Œè€…ï¼Œå¿ è¯šã€é«˜æ•ˆ',
                secretMission: 'æ‰€å±æ•™çˆ¶èµ„æœ¬è¿›å…¥å‰3',
                specialSkill: 'å¿ è¯šæ‰§è¡Œï¼šä¸ºæ•™çˆ¶å®Œæˆä»»åŠ¡æ—¶ï¼Œæ”¶ç›Š+20%',
                initialCapital: 50,
                initialReputation: 30
            }
        };

        // ç‰¹è´¨å¡å®šä¹‰
        const traitCards = {
            'å²©çŸ³': [
                { name: 'åšå®ˆ', effect: 'å…ç–«æœ¬è½®å¸‚åœºåŠ¨è¡æŸå¤±', cost: 0 },
                { name: 'ä¸å¯åŠ¨æ‘‡', effect: 'å…ç–«å£°æœ›æŸå¤±', cost: 0 }
            ],
            'ç­‹éª¨': [
                { name: 'æ‰§è¡Œ', effect: 'ç‹¬ç«‹è¡ŒåŠ¨æ”¶ç›Š+20%', cost: 0 },
                { name: 'è€åŠ›', effect: 'ç”Ÿå­˜æˆæœ¬å‡åŠ', cost: 0 }
            ],
            'æ°´æµ': [
                { name: 'è½¬å‘', effect: 'æ”¾å¼ƒå½“å‰é¡¹ç›®ï¼Œè½¬æŠ•å¦ä¸€é¡¹ç›®', cost: 0 },
                { name: 'é€‚åº”', effect: 'åˆä½œå¤±è´¥æ—¶æŸå¤±å‡åŠ', cost: 0 }
            ],
            'æŒ‡å—é’ˆ': [
                { name: 'é”å®š', effect: 'æœ¬è½®æ‰€æœ‰æ”¶ç›Š+15%', cost: 0 },
                { name: 'æ–¹å‘æ„Ÿ', effect: 'é¢„çŸ¥å•†æœºå¡å†…å®¹', cost: 0 }
            ],
            'é•œé¢': [
                { name: 'æ´å¯Ÿ', effect: 'æŸ¥çœ‹1ä½åˆä½œæ–¹æ˜¯å¦èƒŒå›', cost: 0 },
                { name: 'è¯†äºº', effect: 'æŸ¥çœ‹ä»–äººè§’è‰²èº«ä»½', cost: 0 }
            ],
            'ç«ç„°': [
                { name: 'æ¿€åŠ±', effect: 'æŒ‡å®šé¡¹ç›®ï¼Œæ‰€æœ‰å‚ä¸è€…æ”¶ç›Š+10%', cost: 0 },
                { name: 'æ„ŸæŸ“', effect: 'è¯´æœä»–äººæ”¹å˜å†³ç­–', cost: 0 }
            ],
            'ç›¾ç‰Œ': [
                { name: 'é˜²å¾¡', effect: 'å…ç–«èƒŒå›çš„é¢å¤–æŸå¤±', cost: 0 },
                { name: 'éš”ç¦»', effect: 'æœ¬è½®ä¸å—ä»–äººç‰¹è´¨å¡å½±å“', cost: 0 }
            ],
            'æ¡¥æ¢': [
                { name: 'åˆçºµ', effect: 'ç»„å»ºâ‰¤3äººè”ç›Ÿï¼Œæ”¶ç›Š+20%', cost: 0 },
                { name: 'è¿æ¥', effect: 'ä¿ƒæˆä»–äººåˆä½œï¼Œè·å¾—10%ä½£é‡‘', cost: 0 }
            ]
        };

        // å•†æœºå¡å®šä¹‰
        const opportunityCards = [
            {
                name: 'è“æµ·å¸‚åœº',
                description: 'æ–°å…´å¸‚åœºæœºä¼š',
                rules: 'ç‹¬ç«‹è¡ŒåŠ¨ï¼š50èµ„æœ¬ï¼›2äººåˆä½œï¼šå„40èµ„æœ¬ï¼›3äººä»¥ä¸Šï¼šå„30èµ„æœ¬'
            },
            {
                name: 'æˆ˜ç•¥å¹¶è´­',
                description: 'é«˜é£é™©é«˜æ”¶ç›Šé¡¹ç›®',
                rules: 'ä»…é™2äººåˆä½œï¼ŒæˆåŠŸå„+80èµ„æœ¬ï¼›è‹¥èƒŒå›ï¼ŒèƒŒå›è€…+120ï¼Œè¢«èƒŒå›è€…-40'
            },
            {
                name: 'é‡å¤§å±æœº',
                description: 'å¸‚åœºåŠ¨è¡æœŸ',
                rules: 'æ‰€æœ‰äºº-20èµ„æœ¬ï¼Œåˆä½œè€…å¯äº’ç›¸åˆ†æ‹…æŸå¤±'
            },
            {
                name: 'æ”¿ç­–çº¢åˆ©',
                description: 'æ”¿åºœæ‰¶æŒé¡¹ç›®',
                rules: 'å£°æœ›>60è€…é¢å¤–+30èµ„æœ¬ï¼Œåˆä½œå¯å…±äº«çº¢åˆ©'
            },
            {
                name: 'æŠ€æœ¯é©å‘½',
                description: 'é¢ è¦†æ€§åˆ›æ–°æœºä¼š',
                rules: 'ç‹¬ç«‹è¡ŒåŠ¨é£é™©å¤§ï¼Œåˆä½œå¯é™ä½é£é™©æé«˜æ”¶ç›Š'
            }
        ];

        // åˆå§‹åŒ–æ¸¸æˆ
        function initializeGame() {
            const playerCount = parseInt(document.getElementById('player-count').value);
            gameState.players = [];
            gameState.currentRound = 1;
            gameState.currentPlayerIndex = 0;
            gameState.roundDecisions = [];
            gameState.gameLog = [];

            // åˆ†é…é˜¶çº§å’Œè§’è‰²
            const classDistribution = distributeClasses(playerCount);
            
            for (let i = 0; i < playerCount; i++) {
                const playerClass = classDistribution[i];
                const availableRoles = getRolesForClass(playerClass);
                const role = availableRoles[Math.floor(Math.random() * availableRoles.length)];
                
                const player = {
                    id: i + 1,
                    name: `ç©å®¶${i + 1}`,
                    class: playerClass,
                    role: role,
                    capital: roles[role].initialCapital,
                    reputation: roles[role].initialReputation,
                    traitCards: getInitialTraitCards(playerClass, role),
                    usedTraitCard: null,
                    cooperationHistory: [],
                    betrayalCount: 0,
                    isActive: i === 0
                };
                
                gameState.players.push(player);
            }

            displayPlayers();
            startGame();
            addLog(`æ¸¸æˆå¼€å§‹ï¼å…±${playerCount}åç©å®¶å‚ä¸`);
        }

        // åˆ†é…é˜¶çº§
        function distributeClasses(playerCount) {
            const distribution = [];
            const rulerCount = Math.max(1, Math.floor(playerCount * 0.1));
            const middleCount = Math.floor(playerCount * 0.4);
            const workerCount = playerCount - rulerCount - middleCount;

            for (let i = 0; i < rulerCount; i++) distribution.push('ç»Ÿæ²»é˜¶çº§');
            for (let i = 0; i < middleCount; i++) distribution.push('ä¸­äº§é˜¶çº§');
            for (let i = 0; i < workerCount; i++) distribution.push('æ— äº§é˜¶çº§');

            return distribution;
        }

        // è·å–é˜¶çº§å¯¹åº”çš„è§’è‰²
        function getRolesForClass(playerClass) {
            switch (playerClass) {
                case 'ç»Ÿæ²»é˜¶çº§':
                    return ['æ å¤ºè€…', 'æ•™çˆ¶'];
                case 'ä¸­äº§é˜¶çº§':
                    return ['æ“ç›˜æ‰‹', 'å­¤ç‹¼'];
                case 'æ— äº§é˜¶çº§':
                    return ['é¬£ç‹—', 'ç‹—è…¿å­'];
                default:
                    return ['å­¤ç‹¼'];
            }
        }

        // è·å–åˆå§‹ç‰¹è´¨å¡
        function getInitialTraitCards(playerClass, role) {
            const roleTraits = roles[role].traits;
            const cards = [];
            
            roleTraits.forEach(trait => {
                const availableCards = traitCards[trait];
                const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
                cards.push({ ...randomCard, trait: trait });
            });

            // æ ¹æ®é˜¶çº§æ·»åŠ é¢å¤–å¡ç‰‡
            const extraCards = playerClass === 'ç»Ÿæ²»é˜¶çº§' ? 1 : 0;
            for (let i = 0; i < extraCards; i++) {
                const allTraits = Object.keys(traitCards);
                const randomTrait = allTraits[Math.floor(Math.random() * allTraits.length)];
                const availableCards = traitCards[randomTrait];
                const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
                cards.push({ ...randomCard, trait: randomTrait });
            }

            return cards;
        }

        // æ˜¾ç¤ºç©å®¶ä¿¡æ¯
        function displayPlayers() {
            const container = document.getElementById('players-container');
            container.innerHTML = '';

            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = `player-card ${player.isActive ? 'active' : ''}`;
                playerCard.innerHTML = `
                    <h3>${player.name}</h3>
                    <div class="player-info">
                        <div class="info-item">
                            <div class="info-label">é˜¶çº§</div>
                            <div class="info-value class-${player.class === 'ç»Ÿæ²»é˜¶çº§' ? 'ruler' : player.class === 'ä¸­äº§é˜¶çº§' ? 'middle' : 'worker'}">${player.class}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">è§’è‰²</div>
                            <div class="info-value">${player.role}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">èµ„æœ¬</div>
                            <div class="info-value capital">${player.capital}</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">å£°æœ›</div>
                            <div class="info-value reputation">${player.reputation}</div>
                        </div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">ç§˜å¯†ä»»åŠ¡</div>
                        <div class="info-value" style="font-size: 0.9em;">${roles[player.role].secretMission}</div>
                    </div>
                `;
                container.appendChild(playerCard);
            });
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            document.getElementById('setup-phase').classList.add('hidden');
            document.getElementById('game-phase').classList.remove('hidden');
            gameState.gamePhase = 'playing';
            
            startNewRound();
        }

        // å¼€å§‹æ–°å›åˆ
        function startNewRound() {
            // æ”¯ä»˜ç”Ÿå­˜æˆæœ¬
            gameState.players.forEach(player => {
                player.capital = Math.max(0, player.capital - 20);
            });

            // æŠ½å–å•†æœºå¡
            const opportunity = opportunityCards[Math.floor(Math.random() * opportunityCards.length)];
            
            document.getElementById('round-title').textContent = `ç¬¬${gameState.currentRound}è½® - ${opportunity.name}`;
            document.getElementById('opportunity-card').innerHTML = `
                <h4>${opportunity.name}</h4>
                <p>${opportunity.description}</p>
                <p><strong>è§„åˆ™ï¼š</strong>${opportunity.rules}</p>
            `;

            gameState.currentPlayerIndex = 0;
            gameState.roundDecisions = [];
            
            updateCurrentPlayerDisplay();
            addLog(`ç¬¬${gameState.currentRound}è½®å¼€å§‹ - å•†æœºï¼š${opportunity.name}`);
        }

        // æ›´æ–°å½“å‰ç©å®¶æ˜¾ç¤º
        function updateCurrentPlayerDisplay() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            // æ›´æ–°ç©å®¶çŠ¶æ€
            gameState.players.forEach((player, index) => {
                player.isActive = index === gameState.currentPlayerIndex;
            });
            
            displayPlayers();
            
            // æ˜¾ç¤ºå½“å‰ç©å®¶ä¿¡æ¯
            document.getElementById('player-status').innerHTML = `
                <h4>å½“å‰ç©å®¶ï¼š${currentPlayer.name}</h4>
                <p>è§’è‰²ï¼š${currentPlayer.role}</p>
                <p>èµ„æœ¬ï¼š<span class="capital">${currentPlayer.capital}</span></p>
                <p>å£°æœ›ï¼š<span class="reputation">${currentPlayer.reputation}</span></p>
            `;

            // æ˜¾ç¤ºç‰¹è´¨å¡
            displayTraitCards(currentPlayer);
            
            // æ˜¾ç¤ºåˆä½œé€‰é¡¹
            displayCooperationOptions(currentPlayer);
        }

        // æ˜¾ç¤ºç‰¹è´¨å¡
        function displayTraitCards(player) {
            const container = document.getElementById('trait-cards-container');
            container.innerHTML = '';

            player.traitCards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'trait-card';
                cardElement.onclick = () => selectTraitCard(index);
                cardElement.innerHTML = `
                    <h4>${card.trait} - ${card.name}</h4>
                    <p>${card.effect}</p>
                `;
                container.appendChild(cardElement);
            });
        }

        // é€‰æ‹©ç‰¹è´¨å¡
        function selectTraitCard(cardIndex) {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
            document.querySelectorAll('.trait-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // é€‰æ‹©æ–°å¡ç‰‡
            document.querySelectorAll('.trait-card')[cardIndex].classList.add('selected');
            currentPlayer.selectedTraitCard = cardIndex;
        }

        // æ˜¾ç¤ºåˆä½œé€‰é¡¹
        function displayCooperationOptions(currentPlayer) {
            const container = document.getElementById('cooperation-options');
            container.innerHTML = '';

            gameState.players.forEach(player => {
                if (player.id !== currentPlayer.id && player.reputation > 0) {
                    const option = document.createElement('div');
                    option.className = 'player-option';
                    option.onclick = () => selectCooperationTarget(player.id);
                    option.innerHTML = `
                        <div>${player.name}</div>
                        <div class="capital">${player.capital}</div>
                        <div class="reputation">${player.reputation}</div>
                    `;
                    container.appendChild(option);
                }
            });
        }

        // é€‰æ‹©åˆä½œç›®æ ‡
        function selectCooperationTarget(playerId) {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
            document.querySelectorAll('.player-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // é€‰æ‹©æ–°ç›®æ ‡
            event.target.closest('.player-option').classList.add('selected');
            currentPlayer.selectedTarget = playerId;
        }

        // åšå‡ºå†³ç­–
        function makeDecision(decision) {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            const playerDecision = {
                playerId: currentPlayer.id,
                decision: decision,
                target: currentPlayer.selectedTarget || null,
                traitCard: currentPlayer.selectedTraitCard !== undefined ? currentPlayer.selectedTraitCard : null
            };

            gameState.roundDecisions.push(playerDecision);
            
            addLog(`${currentPlayer.name} åšå‡ºå†³ç­–ï¼š${decision === 'cooperate' ? 'åˆä½œ' : decision === 'betray' ? 'èƒŒå›' : 'ç‹¬ç«‹è¡ŒåŠ¨'}`);
            
            // ä½¿ç”¨ç‰¹è´¨å¡
            if (playerDecision.traitCard !== null) {
                const usedCard = currentPlayer.traitCards[playerDecision.traitCard];
                currentPlayer.usedTraitCard = usedCard;
                addLog(`${currentPlayer.name} ä½¿ç”¨ç‰¹è´¨å¡ï¼š${usedCard.name}`);
            }
        }

        // ä¸‹ä¸€ä½ç©å®¶
        function nextPlayer() {
            gameState.currentPlayerIndex++;
            
            if (gameState.currentPlayerIndex >= gameState.players.length) {
                // æ‰€æœ‰ç©å®¶éƒ½å®Œæˆå†³ç­–ï¼Œè¿›å…¥ç»“ç®—é˜¶æ®µ
                processRound();
            } else {
                updateCurrentPlayerDisplay();
            }
        }

        // å¤„ç†å›åˆç»“ç®—
        function processRound() {
            document.getElementById('game-phase').classList.add('hidden');
            document.getElementById('results-phase').classList.remove('hidden');
            
            const results = calculateRoundResults();
            displayRoundResults(results);
            
            // é‡ç½®ç©å®¶çŠ¶æ€
            gameState.players.forEach(player => {
                player.selectedTraitCard = undefined;
                player.selectedTarget = null;
                player.usedTraitCard = null;
            });
            
            addLog(`ç¬¬${gameState.currentRound}è½®ç»“ç®—å®Œæˆ`);
        }

        // è®¡ç®—å›åˆç»“æœ
        function calculateRoundResults() {
            const results = [];
            const cooperationMap = new Map();
            
            // å»ºç«‹åˆä½œå…³ç³»æ˜ å°„
            gameState.roundDecisions.forEach(decision => {
                if (decision.decision === 'cooperate' && decision.target) {
                    const targetDecision = gameState.roundDecisions.find(d => d.playerId === decision.target);
                    if (targetDecision && targetDecision.target === decision.playerId && targetDecision.decision === 'cooperate') {
                        // åŒæ–¹éƒ½é€‰æ‹©åˆä½œ
                        cooperationMap.set(decision.playerId, { partner: decision.target, mutual: true });
                        cooperationMap.set(decision.target, { partner: decision.playerId, mutual: true });
                    } else if (targetDecision && targetDecision.target === decision.playerId && targetDecision.decision === 'betray') {
                        // å¯¹æ–¹èƒŒå›
                        cooperationMap.set(decision.playerId, { partner: decision.target, mutual: false, betrayed: true });
                        cooperationMap.set(decision.target, { partner: decision.playerId, mutual: false, betrayer: true });
                    }
                }
            });

            // è®¡ç®—æ¯ä¸ªç©å®¶çš„æ”¶ç›Š
            gameState.players.forEach(player => {
                const decision = gameState.roundDecisions.find(d => d.playerId === player.id);
                if (!decision) return;

                let capitalChange = 0;
                let reputationChange = 0;
                let resultText = '';

                const cooperation = cooperationMap.get(player.id);
                
                if (decision.decision === 'independent') {
                    // ç‹¬ç«‹è¡ŒåŠ¨
                    capitalChange = 50;
                    
                    // åº”ç”¨ç‰¹è´¨å¡æ•ˆæœ
                    if (player.usedTraitCard) {
                        if (player.usedTraitCard.name === 'æ‰§è¡Œ') {
                            capitalChange = Math.floor(capitalChange * 1.2);
                        } else if (player.usedTraitCard.name === 'é”å®š') {
                            capitalChange = Math.floor(capitalChange * 1.15);
                        }
                    }
                    
                    // å­¤ç‹¼è§’è‰²ç‹¬ç«‹è¡ŒåŠ¨æ”¶ç›ŠåŠ æˆ
                    if (player.role === 'å­¤ç‹¼') {
                        capitalChange = Math.floor(capitalChange * 1.2);
                    }
                    
                    resultText = `ç‹¬ç«‹è¡ŒåŠ¨è·å¾—${capitalChange}èµ„æœ¬`;
                    
                } else if (cooperation && cooperation.mutual) {
                    // åŒæ–¹åˆä½œæˆåŠŸ
                    capitalChange = 40;
                    reputationChange = 5;
                    
                    // åº”ç”¨ç‰¹è´¨å¡æ•ˆæœ
                    if (player.usedTraitCard) {
                        if (player.usedTraitCard.name === 'åˆçºµ') {
                            capitalChange = Math.floor(capitalChange * 1.2);
                        } else if (player.usedTraitCard.name === 'æ¿€åŠ±') {
                            capitalChange = Math.floor(capitalChange * 1.1);
                            // ç»™åˆä½œä¼™ä¼´ä¹ŸåŠ æˆ
                            const partner = gameState.players.find(p => p.id === cooperation.partner);
                            if (partner) {
                                // è¿™é‡Œéœ€è¦åœ¨åé¢å¤„ç†ä¼™ä¼´çš„åŠ æˆ
                            }
                        }
                    }
                    
                    resultText = `åˆä½œæˆåŠŸï¼Œè·å¾—${capitalChange}èµ„æœ¬ï¼Œå£°æœ›+${reputationChange}`;
                    
                } else if (cooperation && cooperation.betrayed) {
                    // è¢«èƒŒå›
                    capitalChange = -25;
                    reputationChange = 5; // è¢«èƒŒå›è€…ä»è·å¾—å£°æœ›
                    
                    // åº”ç”¨ç‰¹è´¨å¡æ•ˆæœ
                    if (player.usedTraitCard) {
                        if (player.usedTraitCard.name === 'é˜²å¾¡') {
                            capitalChange = Math.floor(capitalChange * 0.5); // å‡å°‘æŸå¤±
                        } else if (player.usedTraitCard.name === 'é€‚åº”') {
                            capitalChange = Math.floor(capitalChange * 0.5);
                        }
                    }
                    
                    resultText = `è¢«èƒŒå›ï¼ŒæŸå¤±${Math.abs(capitalChange)}èµ„æœ¬ï¼Œä½†å£°æœ›+${reputationChange}`;
                    
                } else if (cooperation && cooperation.betrayer) {
                    // èƒŒå›ä»–äºº
                    capitalChange = 60;
                    reputationChange = -15;
                    player.betrayalCount++;
                    
                    resultText = `èƒŒå›æˆåŠŸï¼Œè·å¾—${capitalChange}èµ„æœ¬ï¼Œå£°æœ›${reputationChange}`;
                    
                } else if (decision.decision === 'cooperate' && !cooperation) {
                    // æƒ³åˆä½œä½†æ²¡æœ‰æ‰¾åˆ°åˆä½œä¼™ä¼´
                    capitalChange = 25; // è·å¾—å°‘é‡èµ„æœ¬
                    resultText = `æœªæ‰¾åˆ°åˆä½œä¼™ä¼´ï¼Œç‹¬è‡ªè¡ŒåŠ¨è·å¾—${capitalChange}èµ„æœ¬`;
                }

                // åº”ç”¨å¸‚åœºåŠ¨è¡ï¼ˆéšæœºäº‹ä»¶ï¼‰
                if (Math.random() < 0.2) { // 20%æ¦‚ç‡
                    const volatility = Math.floor(Math.random() * 20) - 10; // -10åˆ°+10
                    if (player.usedTraitCard && player.usedTraitCard.name === 'åšå®ˆ' && volatility < 0) {
                        // å…ç–«è´Ÿé¢å¸‚åœºåŠ¨è¡
                        resultText += 'ï¼Œå…ç–«å¸‚åœºåŠ¨è¡';
                    } else {
                        capitalChange += volatility;
                        if (volatility > 0) {
                            resultText += `ï¼Œå¸‚åœºåˆ©å¥½+${volatility}`;
                        } else {
                            resultText += `ï¼Œå¸‚åœºåŠ¨è¡${volatility}`;
                        }
                    }
                }

                // åº”ç”¨å˜åŒ–
                player.capital = Math.max(0, player.capital + capitalChange);
                player.reputation = Math.max(0, Math.min(100, player.reputation + reputationChange));
                
                // æ£€æŸ¥é˜¶çº§æµåŠ¨
                checkClassMobility(player);
                
                results.push({
                    player: player,
                    capitalChange: capitalChange,
                    reputationChange: reputationChange,
                    resultText: resultText
                });
            });

            return results;
        }

        // æ£€æŸ¥é˜¶çº§æµåŠ¨
        function checkClassMobility(player) {
            const sortedPlayers = [...gameState.players].sort((a, b) => b.capital - a.capital);
            const playerRank = sortedPlayers.findIndex(p => p.id === player.id) + 1;
            const totalPlayers = gameState.players.length;
            
            let newClass = player.class;
            
            // æ™‹å‡æ¡ä»¶
            if (player.class === 'æ— äº§é˜¶çº§' && playerRank <= Math.ceil(totalPlayers * 0.4)) {
                newClass = 'ä¸­äº§é˜¶çº§';
            } else if (player.class === 'ä¸­äº§é˜¶çº§' && playerRank <= Math.ceil(totalPlayers * 0.1)) {
                newClass = 'ç»Ÿæ²»é˜¶çº§';
            }
            
            // è·Œè½æ¡ä»¶
            if (player.class === 'ç»Ÿæ²»é˜¶çº§' && playerRank > Math.ceil(totalPlayers * 0.3)) {
                newClass = 'ä¸­äº§é˜¶çº§';
                player.reputation = Math.max(0, player.reputation - 30); // ä¿¡ä»»å±æœº
                addLog(`${player.name} é­é‡ä¿¡ä»»å±æœºï¼Œå£°æœ›-30`);
            } else if (player.class === 'ä¸­äº§é˜¶çº§' && playerRank > Math.ceil(totalPlayers * 0.7)) {
                newClass = 'æ— äº§é˜¶çº§';
            }
            
            if (newClass !== player.class) {
                addLog(`${player.name} ä»${player.class}${newClass === 'ç»Ÿæ²»é˜¶çº§' ? 'æ™‹å‡' : newClass === 'æ— äº§é˜¶çº§' ? 'è·Œè½' : 'è½¬å˜'}ä¸º${newClass}`);
                player.class = newClass;
                player.reputation += newClass === 'ç»Ÿæ²»é˜¶çº§' ? 10 : 0;
                
                // æ™‹å‡å¥–åŠ±ç‰¹è´¨å¡
                if (newClass === 'ç»Ÿæ²»é˜¶çº§' || newClass === 'ä¸­äº§é˜¶çº§') {
                    const newCard = getRandomTraitCard();
                    player.traitCards.push(newCard);
                    addLog(`${player.name} è·å¾—æ–°ç‰¹è´¨å¡ï¼š${newCard.name}`);
                }
            }
        }

        // è·å–éšæœºç‰¹è´¨å¡
        function getRandomTraitCard() {
            const allTraits = Object.keys(traitCards);
            const randomTrait = allTraits[Math.floor(Math.random() * allTraits.length)];
            const availableCards = traitCards[randomTrait];
            const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
            return { ...randomCard, trait: randomTrait };
        }

        // æ˜¾ç¤ºå›åˆç»“æœ
        function displayRoundResults(results) {
            const container = document.getElementById('round-results');
            container.innerHTML = '<h3>æœ¬è½®ç»“æœ</h3>';

            results.forEach(result => {
                const resultElement = document.createElement('div');
                resultElement.style.marginBottom = '15px';
                resultElement.style.padding = '10px';
                resultElement.style.backgroundColor = 'rgba(255,255,255,0.1)';
                resultElement.style.borderRadius = '5px';
                resultElement.innerHTML = `
                    <p><strong>${result.player.name}</strong> (${result.player.role}): ${result.resultText}</p>
                    <p>å½“å‰èµ„æœ¬: <span class="capital">${result.player.capital}</span>, 
                       å½“å‰å£°æœ›: <span class="reputation">${result.player.reputation}</span>,
                       é˜¶çº§: <span class="class-${result.player.class === 'ç»Ÿæ²»é˜¶çº§' ? 'ruler' : result.player.class === 'ä¸­äº§é˜¶çº§' ? 'middle' : 'worker'}">${result.player.class}</span></p>
                `;
                container.appendChild(resultElement);
            });

            // æ·»åŠ è´­å¡é€‰é¡¹
            const buyCardSection = document.createElement('div');
            buyCardSection.innerHTML = `
                <h4>è´­ä¹°ç‰¹è´¨å¡ (30èµ„æœ¬/å¼ )</h4>
                <div id="buy-card-options" class="trait-cards"></div>
                <button class="btn" onclick="showBuyCardOptions()">æ˜¾ç¤ºå¯è´­ä¹°å¡ç‰‡</button>
            `;
            container.appendChild(buyCardSection);
        }

        // æ˜¾ç¤ºè´­å¡é€‰é¡¹
        function showBuyCardOptions() {
            const container = document.getElementById('buy-card-options');
            container.innerHTML = '';
            
            // ç”Ÿæˆ3å¼ éšæœºå¡ç‰‡ä¾›è´­ä¹°
            for (let i = 0; i < 3; i++) {
                const card = getRandomTraitCard();
                const cardElement = document.createElement('div');
                cardElement.className = 'trait-card';
                cardElement.onclick = () => buyTraitCard(card);
                cardElement.innerHTML = `
                    <h4>${card.trait} - ${card.name}</h4>
                    <p>${card.effect}</p>
                    <p><strong>ä»·æ ¼: 30èµ„æœ¬</strong></p>
                `;
                container.appendChild(cardElement);
            }
        }

        // è´­ä¹°ç‰¹è´¨å¡
        function buyTraitCard(card) {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            if (currentPlayer.capital >= 30) {
                currentPlayer.capital -= 30;
                currentPlayer.traitCards.push(card);
                addLog(`${currentPlayer.name} è´­ä¹°äº†ç‰¹è´¨å¡ï¼š${card.name}`);
                
                // æ›´æ–°æ˜¾ç¤º
                displayPlayers();
                
                // ç§»é™¤å·²è´­ä¹°çš„å¡ç‰‡
                event.target.remove();
            } else {
                alert('èµ„æœ¬ä¸è¶³ï¼');
            }
        }

        // ä¸‹ä¸€è½®
        function nextRound() {
            if (gameState.currentRound >= 5) {
                endGame();
                return;
            }
            
            gameState.currentRound++;
            gameState.currentPlayerIndex = 0;
            gameState.roundDecisions = [];
            
            // é‡ç½®æ‰€æœ‰ç©å®¶çŠ¶æ€
            gameState.players.forEach(player => {
                player.selectedTraitCard = undefined;
                player.selectedTarget = null;
                player.usedTraitCard = null;
            });
            
            document.getElementById('results-phase').classList.add('hidden');
            document.getElementById('game-phase').classList.remove('hidden');
            
            addLog(`å¼€å§‹ç¬¬${gameState.currentRound}è½®`);
            updateGameDisplay();
        }

        // ç»“æŸæ¸¸æˆ
        function endGame() {
            document.getElementById('results-phase').classList.add('hidden');
            document.getElementById('final-results').classList.remove('hidden');
            
            // è®¡ç®—æœ€ç»ˆæ’å
            const finalRanking = [...gameState.players].sort((a, b) => {
                // é¦–å…ˆæŒ‰èµ„æœ¬æ’åºï¼Œç„¶åæŒ‰å£°æœ›æ’åº
                if (b.capital !== a.capital) return b.capital - a.capital;
                return b.reputation - a.reputation;
            });
            
            // ç”Ÿæˆæ ‡ç­¾
            finalRanking.forEach((player, index) => {
                player.finalRank = index + 1;
                player.tags = generatePlayerTags(player);
            });
            
            displayFinalResults(finalRanking);
        }

        // ç”Ÿæˆç©å®¶æ ‡ç­¾
        function generatePlayerTags(player) {
            const tags = [];
            
            // åŸºäºæœ€ç»ˆæ’åçš„æ ‡ç­¾
            if (player.finalRank === 1) {
                tags.push('å•†ä¸šå·¨å¤´');
            } else if (player.finalRank <= 2) {
                tags.push('æˆåŠŸä¼ä¸šå®¶');
            } else if (player.finalRank >= gameState.players.length - 1) {
                tags.push('å•†åœºå¤±æ„è€…');
            }
            
            // åŸºäºèƒŒå›æ¬¡æ•°çš„æ ‡ç­¾
            if (player.betrayalCount >= 3) {
                tags.push('èƒŒå›ä¸“å®¶');
            } else if (player.betrayalCount === 0) {
                tags.push('è¯šä¿¡å•†äºº');
            }
            
            // åŸºäºå£°æœ›çš„æ ‡ç­¾
            if (player.reputation >= 80) {
                tags.push('å£°èª‰å“è‘—');
            } else if (player.reputation <= 20) {
                tags.push('å£°åç‹¼è—‰');
            }
            
            // åŸºäºé˜¶çº§çš„æ ‡ç­¾
            if (player.class === 'ç»Ÿæ²»é˜¶çº§') {
                tags.push('æƒåŠ›ç²¾è‹±');
            } else if (player.class === 'æ— äº§é˜¶çº§' && player.capital > 200) {
                tags.push('è‰æ ¹é€†è¢­');
            }
            
            // åŸºäºè§’è‰²ç‰¹æ€§çš„æ ‡ç­¾
            if (player.role === 'å­¤ç‹¼' && player.finalRank <= 2) {
                tags.push('ç‹¬è¡Œä¾ ');
            } else if (player.role === 'åˆä½œè€…' && player.betrayalCount === 0) {
                tags.push('å›¢é˜Ÿç²¾ç¥');
            } else if (player.role === 'æŠ•æœºè€…' && player.capital >= 300) {
                tags.push('æŠ•æœºå¤©æ‰');
            }
            
            // åŸºäºç‰¹è´¨å¡æ•°é‡çš„æ ‡ç­¾
            if (player.traitCards.length >= 5) {
                tags.push('èµ„æºå¤§å¸ˆ');
            }
            
            return tags.slice(0, 3); // æœ€å¤š3ä¸ªæ ‡ç­¾
        }

        // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
        function displayFinalResults(ranking) {
            const container = document.getElementById('final-ranking');
            container.innerHTML = '<h3>æœ€ç»ˆæ’å</h3>';
            
            ranking.forEach((player, index) => {
                const rankElement = document.createElement('div');
                rankElement.className = 'final-rank-item';
                rankElement.style.marginBottom = '20px';
                rankElement.style.padding = '15px';
                rankElement.style.backgroundColor = index === 0 ? 'rgba(255,215,0,0.2)' : 
                                                   index === 1 ? 'rgba(192,192,192,0.2)' : 
                                                   index === 2 ? 'rgba(205,127,50,0.2)' : 
                                                   'rgba(255,255,255,0.1)';
                rankElement.style.borderRadius = '10px';
                rankElement.style.border = index === 0 ? '2px solid gold' : '1px solid rgba(255,255,255,0.3)';
                
                const medal = index === 0 ? 'ğŸ†' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}`;
                
                rankElement.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4>${medal} ${player.name}</h4>
                            <p>è§’è‰²: ${player.role} | é˜¶çº§: ${player.class}</p>
                            <p>èµ„æœ¬: <span class="capital">${player.capital}</span> | å£°æœ›: <span class="reputation">${player.reputation}</span></p>
                            <p>èƒŒå›æ¬¡æ•°: ${player.betrayalCount} | ç‰¹è´¨å¡: ${player.traitCards.length}å¼ </p>
                        </div>
                    </div>
                    <div class="player-tags" style="margin-top: 10px;">
                        ${player.tags.map(tag => `<span class="tag">${tag}</span>`).join(' ')}
                    </div>
                `;
                container.appendChild(rankElement);
            });
            
            // æ·»åŠ æ¸¸æˆç»Ÿè®¡
            const statsElement = document.createElement('div');
            statsElement.innerHTML = `
                <h3>æ¸¸æˆç»Ÿè®¡</h3>
                <p>æ€»è½®æ•°: 5è½®</p>
                <p>æ€»èƒŒå›æ¬¡æ•°: ${ranking.reduce((sum, p) => sum + p.betrayalCount, 0)}</p>
                <p>å¹³å‡èµ„æœ¬: ${Math.round(ranking.reduce((sum, p) => sum + p.capital, 0) / ranking.length)}</p>
                <p>å¹³å‡å£°æœ›: ${Math.round(ranking.reduce((sum, p) => sum + p.reputation, 0) / ranking.length)}</p>
            `;
            container.appendChild(statsElement);
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState = {
                players: [],
                currentRound: 1,
                currentPlayerIndex: 0,
                roundDecisions: [],
                gameLog: []
            };
            
            // éšè—æ‰€æœ‰é˜¶æ®µï¼Œæ˜¾ç¤ºè§’è‰²åˆ›å»º
            document.getElementById('final-results').classList.add('hidden');
            document.getElementById('character-creation').classList.remove('hidden');
            
            // æ¸…ç©ºè¾“å…¥
            document.getElementById('player-name').value = '';
            document.getElementById('player-count').value = '4';
            
            // æ¸…ç©ºæ˜¾ç¤º
            document.getElementById('players-list').innerHTML = '';
            document.getElementById('game-log').innerHTML = '';
        }

        // æ·»åŠ æ—¥å¿—
        function addLog(message) {
            gameState.gameLog.push({
                timestamp: new Date().toLocaleTimeString(),
                message: message
            });

            const logContainer = document.getElementById('game-log');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `[${gameState.gameLog[gameState.gameLog.length - 1].timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // åˆå§‹åŒ–é¡µé¢
        document.addEventListener('DOMContentLoaded', function() {
            addLog('æ¬¢è¿æ¥åˆ°å•†ä¸šä¸›æ—æ³•åˆ™ï¼');
        });

        // æ›´æ–°æ¸¸æˆæ˜¾ç¤º
        function updateGameDisplay() {
            // æ›´æ–°å½“å‰è½®æ•°æ˜¾ç¤º
            const roundDisplays = document.querySelectorAll('#current-round-display, .round-indicator');
            roundDisplays.forEach(display => {
                display.textContent = gameState.currentRound;
            });
            
            // æ›´æ–°ç©å®¶ä¿¡æ¯æ˜¾ç¤º
            displayPlayers();
            
            // æ›´æ–°å½“å‰ç©å®¶æŒ‡ç¤º
            const currentPlayerName = gameState.players[gameState.currentPlayerIndex]?.name || '';
            const currentPlayerDisplays = document.querySelectorAll('.current-player-name');
            currentPlayerDisplays.forEach(display => {
                display.textContent = currentPlayerName;
            });
        }

        // è®¡ç®—ç©å®¶ç»¼åˆå¾—åˆ†ï¼ˆç”¨äºæœ€ç»ˆæ’åï¼‰
        function calculatePlayerScore(player) {
            let score = 0;
            
            // èµ„æœ¬æƒé‡ (40%)
            score += player.capital * 0.4;
            
            // å£°æœ›æƒé‡ (30%)
            score += player.reputation * 3 * 0.3; // å£°æœ›æœ€å¤§100ï¼Œä¹˜ä»¥3ä½¿å…¶ä¸èµ„æœ¬ç›¸å½“
            
            // é˜¶çº§åŠ æˆ (20%)
            const classBonus = {
                'ç»Ÿæ²»é˜¶çº§': 100,
                'ä¸­äº§é˜¶çº§': 50,
                'æ— äº§é˜¶çº§': 0
            };
            score += classBonus[player.class] * 0.2;
            
            // ç‰¹è´¨å¡æ•°é‡åŠ æˆ (10%)
            score += player.traitCards.length * 10 * 0.1;
            
            // èƒŒå›æƒ©ç½š
            score -= player.betrayalCount * 20;
            
            return Math.round(score);
        }

        // è·å–ç©å®¶æ’å
        function getPlayerRanking() {
            return [...gameState.players]
                .map(player => ({
                    ...player,
                    score: calculatePlayerScore(player)
                }))
                .sort((a, b) => b.score - a.score)
                .map((player, index) => ({
                    ...player,
                    rank: index + 1
                }));
        }

        // æ˜¾ç¤ºå®æ—¶æ’å
        function displayCurrentRanking() {
            const ranking = getPlayerRanking();
            const container = document.getElementById('current-ranking');
            
            if (container) {
                container.innerHTML = '<h4>å½“å‰æ’å</h4>';
                ranking.forEach(player => {
                    const rankElement = document.createElement('div');
                    rankElement.style.padding = '5px';
                    rankElement.style.marginBottom = '5px';
                    rankElement.style.backgroundColor = 'rgba(255,255,255,0.1)';
                    rankElement.style.borderRadius = '3px';
                    rankElement.innerHTML = `
                        <span>${player.rank}. ${player.name}</span>
                        <span style="float: right;">å¾—åˆ†: ${player.score}</span>
                    `;
                    container.appendChild(rankElement);
                });
            }
        }

        // æ·»åŠ å•†æœºå¡ç³»ç»Ÿ
        const businessOpportunities = [
            {
                name: 'ç§‘æŠ€åˆ›æ–°',
                description: 'æŠ•èµ„æ–°å…´ç§‘æŠ€é¡¹ç›®',
                cost: 80,
                reward: { capital: 120, reputation: 10 },
                risk: 0.3,
                requirements: { class: ['ç»Ÿæ²»é˜¶çº§', 'ä¸­äº§é˜¶çº§'] }
            },
            {
                name: 'å¸‚åœºæ‰©å¼ ',
                description: 'å¼€æ‹“æ–°çš„å¸‚åœºé¢†åŸŸ',
                cost: 60,
                reward: { capital: 90, reputation: 5 },
                risk: 0.2,
                requirements: {}
            },
            {
                name: 'äººæ‰æ”¶è´­',
                description: 'æŒ–æ˜ç«äº‰å¯¹æ‰‹çš„æ ¸å¿ƒäººæ‰',
                cost: 40,
                reward: { capital: 50, reputation: -5 },
                risk: 0.1,
                requirements: {}
            },
            {
                name: 'æ”¿åºœåˆä½œ',
                description: 'ä¸æ”¿åºœéƒ¨é—¨å»ºç«‹åˆä½œå…³ç³»',
                cost: 100,
                reward: { capital: 80, reputation: 20 },
                risk: 0.4,
                requirements: { reputation: 60 }
            },
            {
                name: 'æ…ˆå–„æ´»åŠ¨',
                description: 'ç»„ç»‡å¤§å‹æ…ˆå–„æ´»åŠ¨æå‡å½¢è±¡',
                cost: 50,
                reward: { capital: 20, reputation: 25 },
                risk: 0.1,
                requirements: {}
            }
        ];

        // ç”Ÿæˆå•†æœºå¡
        function generateBusinessOpportunity() {
            const availableOpportunities = businessOpportunities.filter(opp => {
                const player = gameState.players[gameState.currentPlayerIndex];
                
                // æ£€æŸ¥é˜¶çº§è¦æ±‚
                if (opp.requirements.class && !opp.requirements.class.includes(player.class)) {
                    return false;
                }
                
                // æ£€æŸ¥å£°æœ›è¦æ±‚
                if (opp.requirements.reputation && player.reputation < opp.requirements.reputation) {
                    return false;
                }
                
                // æ£€æŸ¥èµ„æœ¬è¦æ±‚
                if (player.capital < opp.cost) {
                    return false;
                }
                
                return true;
            });
            
            if (availableOpportunities.length === 0) return null;
            
            return availableOpportunities[Math.floor(Math.random() * availableOpportunities.length)];
        }

        // å¤„ç†å•†æœºå¡
        function handleBusinessOpportunity(opportunity, accept) {
            const player = gameState.players[gameState.currentPlayerIndex];
            
            if (!accept) {
                addLog(`${player.name} æ”¾å¼ƒäº†å•†æœºï¼š${opportunity.name}`);
                return;
            }
            
            if (player.capital < opportunity.cost) {
                addLog(`${player.name} èµ„æœ¬ä¸è¶³ï¼Œæ— æ³•æŠ•èµ„${opportunity.name}`);
                return;
            }
            
            player.capital -= opportunity.cost;
            
            // è®¡ç®—é£é™©
            const success = Math.random() > opportunity.risk;
            
            if (success) {
                player.capital += opportunity.reward.capital;
                player.reputation = Math.max(0, Math.min(100, player.reputation + opportunity.reputation));
                addLog(`${player.name} æŠ•èµ„${opportunity.name}æˆåŠŸï¼è·å¾—${opportunity.reward.capital}èµ„æœ¬ï¼Œå£°æœ›${opportunity.reward.reputation > 0 ? '+' : ''}${opportunity.reward.reputation}`);
            } else {
                // å¤±è´¥åªæŸå¤±æŠ•èµ„ï¼Œä¸è·å¾—æ”¶ç›Š
                addLog(`${player.name} æŠ•èµ„${opportunity.name}å¤±è´¥ï¼ŒæŸå¤±${opportunity.cost}èµ„æœ¬`);
            }
            
            displayPlayers();
        }
    </script>
</body>
</html>
